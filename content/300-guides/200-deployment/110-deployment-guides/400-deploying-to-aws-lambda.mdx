---
title: 'Deploy to AWS Lambda'
metaTitle: 'Deploy to AWS Lambda'
metaDescription: 'Learn how to deploy Node.js and TypeScript applications based on Prisma Client to AWS Lambda.'
---

<TopBlock>

This guide explains how to set up and deploy a serverless Node.js REST API to [AWS Lambda](https://aws.amazon.com/lambda/) with the Serverless Framework.

AWS Lambda is part of the AWS cloud platform. You can use it to run your code in a serverless environment. To deploy a REST API to AWS Lambda, you must also use [S3](https://aws.amazon.com/s3/) to host the files and [API Gateway](https://aws.amazon.com/api-gateway/) to expose the API over HTTP.

The [Serverless Framework](https://www.serverless.com/) simplifies deployment to Lambda. It provides a CLI that helps with workflow automation and AWS resource provisioning.

The REST API uses Prisma Client to fetch, create, and delete records from a database. Each function represents a REST resource endpoint and uses Prisma Client to handle database operations against a PostgreSQL database hosted on a platform such as Supabase.

** say something like: This guide covers how to deploy a rest API that uses Prisma Client to... **

This guide shows how to deploy an API based on Prisma to AWS Lambda. The starting point is the [Prisma AWS example](https://github.com/prisma/prisma-examples/tree/latest/deployment-platforms/aws-lambda), which has example REST endpoints preconfigured as serverless functions.

<Admonition type="info">

** If you deploy GraphQL servers to AWS Lambda **

This example uses REST, but the same principles apply to a GraphQL server. The main difference is that you typically only need a single function to serve a GraphQL API.

In that function, set the `context.callbackWaitsForEmptyEventLoop` of the [AWS Lambda Context Object](https://docs.aws.amazon.com/lambda/latest/dg/nodejs-context.html) to `false` as follows:

```js
exports.server = (event, context, cb) => {
  // Set to false to send the response right away when the callback executes.
  // Don't wait for the Node.js event loop to be empty.
  context.callbackWaitsForEmptyEventLoop = false

  return lambda.graphqlHandler(event, context, cb)
}
```

</Admonition>

</TopBlock>

## Prerequisites

- a hosted PostgreSQL database and a URL from which your application can access it, such as `postgresql://username:password@your_postgres_db.cloud.com/db_identifier` (you can use Supabase, which offers a [free plan](https://dev.to/prisma/set-up-a-free-postgresql-database-on-supabase-to-use-with-prisma-3pk6)).
- an [AWS](https://aws.amazon.com/) account and a corresponding [access key](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html) for programmatic access.
- a [Serverless Framework CLI](https://www.serverless.com/framework/docs/getting-started/) installed.
- PostgreSQL CLI `psql` installed.
- Node.js installed.

## Prisma workflow

The workflow varies based on whether you integrate with an existing database or create a new one from scratch. Regardless of the workflow, Prisma relies on the Prisma schema (your `schema.prisma` file).

This guide starts with an empty database created with plain SQL and looks as follows:

** TBW: I think this part is unclear - it isn't a set of prerequisite steps, and it doesn't mirror the structure of the page. Are we saying do these now, or that we'll do these below? **

1. Define the database schema with SQL.
1. Run `prisma db pull` locally, which introspects and populates the `schema.prisma` with models based on the database schema.
1. Run `prisma generate` which generates Prisma Client based on the Prisma schema.

## 1. Download the example project

### Steps

Open a terminal window and navigate to a location of your choice. Use the following commands to create a directory for the project and download the example code:

```terminal
mkdir prisma-aws-lambda
cd prisma-aws-lambda
curl https://codeload.github.com/prisma/prisma-examples/tar.gz/latest | tar -xz --strip=3 prisma-examples-latest/deployment-platforms/aws-lambda/
```

Now install the dependencies:

```terminal
npm install
```

<!-- tar strip folder is a concatenation of the REPOSITORY-BRANCH/REF, e.g. prisma-examples-latest -->

### Result

Your directory contains the following files:

```terminal no-copy
README.md
handlers
node_modules
package-lock.json
package.json
prisma
schema.sql
serverless.yml
```

## 2. Set the DATABASE_URL environment variable locally

### Steps

Set the `DATABASE_URL` environment variable locally as follows. This lets you create the database schema and ensures that Prisma can access the database to introspect.

```terminal
export DATABASE_URL="postgresql://__USER__:__PASSWORD__@__HOST__/__DATABASE__"
```

> **Note:** you need the `DATABASE_URL` environment variable for the subsequent steps in this guide. Set it in all terminal sessions related to this project.

You need to replace the uppercase placeholders with your database credentials. For example:

```terminal
postgresql://janedoe:randompassword@yourpostgres.compute-1.amazonaws.com:5432/yourdbname
```

## 3. Set the DATABASE_URL in `.env`

The Lambda functions need access to the `DATABASE_URL` environment variable so that they can access the database. You must define an `.env` file which the preconfigured `serverless-dotenv-plugin` uses to inject into the function runtime. The repository contains an `.env.example` example file to assist with this.

Enter the following command to copy `.env.example` to a new file, `.env`:

```
cp .env.example .env
```

Open `.env` and set the `DATABASE_URL` to the database credentials from step 2.

> **Note:** It's best practice to keep secret information, such as `DATABASE_URL`, out of your git repository. To do this, add your `.env` file to `.gitignore`. This guide copies the source and does not create a repository, so you only need to update `.gitignore` if you initialize a repository.

## 4. Create the database schema

To create your database schema, run `schema.sql` from the example code with the following command:

```terminal
psql $DATABASE_URL -f schema.sql
```

### Result

Run the following command:

```terminal
psql $DATABASE_URL -c "\dt"
```

It shows a list of tables similar to the following:

```terminal no-copy
          List of relations
 Schema | Name    | Type  | Owner
 --------+---------+-------+-----------
 public | Post    | table | janedoe
 public | Profile | table | janedoe
 public | User    | table | janedoe
```

Congratulations, you have successfully created the database schema!

## 5. Introspect the database

### Steps

Introspect the database with the following Prisma CLI command:

```terminal
npx prisma db pull
```

** Let's rewrite this to use npx prisma db push - to push the schema to the database**

** Need to change connection string to use port Use port 5432, not the default 6543 - this is a supabase/prisma issue IF you use migrate - if we're using push, we probably don't need to **

** Rewrite to use prisma migrate npx prisma migrate dev --name init. -> npx prisma migrate dev <- worked for me This creates a new SQL migration frile in the prisma/migrations irectory and runs the miration file against the database. Then it creates the database. We do this above - to create the database, then we can check for the tables**

Prisma introspects the database that is defined in the `datasource` block of the Prisma schema. It populates the Prisma schema with models corresponding to the database tables.

### Result

The models in `prisma/schema.prisma` are as follows:

**TBD: In the example repo, the Post>User field is now author -> this breaks our example later where we change the name. Whose demo is it? Need to check with them - discussion with Niko - see notes later **

```prisma file=schema.prisma no-copy
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  posts   Post[]
  profile Profile?
}
```

### Generate Prisma Client

Run `prisma generate` to generate Prisma Client based on your new Prisma schema:

```terminal
npx prisma generate
```

<Admonition type = "info">

When you make changes to your Prisma schema, invoke `prisma generate` to update your Prisma Client API.

</Admonition>

### Rename the relation fields for easy access

** This whole section can come out if we're using migration, not introspection **
** OTOH, if we are using introspection, then the example project field names are already "fixed", so we will need to resolve that **

**TBW: this is the explanation**

In the example schema, the generated `Post` and `Profile` fields in the `User` model are _virtual_. This means that they are _not backed by a foreign key in the database_). You can manually rename them in the schema to give them more meanginful names in the context of the relation. This only affects the generated client.

In the Prisma schema there are two types of relation fields:

- Relation fields: these have a model name as the type, such as the `User` field in the `Post` model. You can rename a relation field to better fit its usage, such as `user` -> `author`.
- [Relation scalar fields](/concepts/components/prisma-schema/relations): these store the foreign key, such as the `authorId` field in the `Post` model. You cannot rename a relation scalar field, because it must match the corresponding field in the database.

Prisma Client uses the names of the relation fields to access the corresponding relations.

Note that there [naming conventions](/reference/api-reference/prisma-schema-reference#naming-conventions-1) for model fields.

The following example uses a relation field to fetch a specific `Post` and its associated `User` object:

```js no-copy
const postAuthor = await prisma.post.findUnique({
  where: { id: 1 },
  include: { User: true },
})
```

If you rename the `User` field in the `Post` model to `author`, you can access it as follows:

```js no-copy
const postAuthor = await prisma.post.findUnique({
  where: { id: 1 },
  include: { author: true },
})
```

**TBW: this is the action - need to make this division clearer**

\*\*Also - field issues in example project

- Post: User -> author
- Profile: User-->user
- User:
  - Post-->posts
  - Profile-->profile

\*\*

Rename the relation fields as follows.

```prisma file=schema.prisma
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @db.Timestamp(6)
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction) // renamed from `User` -> `author`
  authorId  Int // relation scalar field
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique // relation scalar field
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)) // renamed from `User` -> `user`
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?  @unique @db.VarChar(255)
  posts   Post[] // renamed from `Post` -> `posts`
  profile Profile? // renamed from `Profile` -> `profile`
}
```

Run `prisma generate` again to regenerate Prisma Client based on the new state of the schema:

```terminal
npx prisma generate
```

## 6. Set the AWS Access key as an environment variable

In order for the Serverless Framework to provision the AWS resources and deploy your application, you must configure the access key.

The method you use to get the access key depends on whether you use your personal account or create a special IAM user for the Serverless Framework. We recommend that you create a special IAm user because it allows you to set granular permissions. To get an access key for your account, follow the [AWS guide](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html#Using_CreateAccessKey)

** TBD: I am not sure if the above link applies to a personal account, an IAM user, or both - the above needs to be clarified **

When you have the _Access key ID_ and a _Secret access key_, set them with the following command:

```
serverless config credentials --provider aws --key AWS_ACCESS_KEY_ID  --secret AWS_SECRET_ACCESS_KEY
```

## 7. Deploy the app

### Steps

To deploy your project, use the following command:

```terminal
serverless deploy
```

**TBD: I installed serverless as part of my project with npm. therefore I run `npx serverless deploy` Need to decide whether to update the above command **

Serverless creates the AWS resources and uploads your code, then outputs the service information. For example:

```code no-copy
Service Information
service: prisma-aws-lambda-example
stage: dev
region: us-east-1
stack: prisma-aws-lambda-example-dev
resources: 39
api keys:
  None
endpoints:
  GET - https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/
  GET - https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/seed
  GET - https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/users
  POST - https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/users
  GET - https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/posts
functions:
  status: prisma-aws-lambda-example-dev-status
  seed: prisma-aws-lambda-example-dev-seed
  getUsers: prisma-aws-lambda-example-dev-getUsers
  createUser: prisma-aws-lambda-example-dev-createUser
  getPosts: prisma-aws-lambda-example-dev-getPosts
layers:
  None
```

### Result

Call the status endpoint as follows. Replace `UNIQUE_IDENTIFIER` with the corresponding part of the URL from the output you got from `serverless deploy`.

```terminal
curl https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/
```

This returns `{"up":true}`

## 8. Test your deployed REST API

With the API base URL: `https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/`, you can test the API's endpoints:

| Endpoint      | Description                                                                                                              | Implementation            |
| ------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------------- |
| `GET /`       | Status                                                                                                                   | `handlers/status.js`      |
| `GET /seed`   | Delete all database records and seed the database with test `users`, `profiles`, and `posts`. Returns the created users. | `handlers/seed.js`        |
| `GET /users`  | Fetch all `users` in the database with their related `profiles`                                                          | `handlers/users.js`       |
| `POST /users` | Create a single `users` in the database                                                                                  | `handlers/create-user.js` |
| `GET /posts`  | Fetch all `posts` and their related `authors`                                                                            | `handlers/posts.js`       |

To call the API, you can use curl. Again, replace `UNIQUE_IDENTIFIER` with the corresponding part of the URL from the output you got from `serverless deploy`.

```
curl -v https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/seed
```

## Notes

### <inlinecode>serverless.yml</inlinecode>

The `serverless.yml` configuration file contains the endpoint and function configuration. You can update this file to add or change endpoints. For more AWS specific configuration information, see the AWS provider configuration in the [Serverless Framework Docs](https://serverless.com/framework/docs/providers/aws/guide/functions/).

### Binary targets in <inlinecode>schema.prisma</inlinecode>

The Prisma schema contains the following in the generator block:

```prisma
binaryTargets = ["native", "rhel-openssl-1.0.x"]
```

This is necessary because the local runtime is different to the Lambda runtime. Add the `binaryTarget` to make the compatible Prisma Engine binary available.

### Package Pattern in <inlinecode>serverless.yml</inlinecode>

The Serverless configuration file includes a package pattern that excludes all Prisma Engine binaries except for the one relevant for the Lambda runtime. This means that only one binary is included when Serverless packages your app for upload:

```
package:
  patterns:
    - '!node_modules/.prisma/client/libquery_engine-*'
    - 'node_modules/.prisma/client/libquery_engine-rhel-*'
    - '!node_modules/prisma/libquery_engine-*'
    - '!node_modules/@prisma/engines/**'
```

This ensures the packaged archive is as small as possible.

But, if you are using `serverless-webpack`, you cannot use that method.

### Lambdas with arm64 architectures

Lambda functions that use [arm64 architectures (AWS Graviton2 processor)](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html#foundation-arch-adv) must use an `arm64` precompiled binary.

In the `generator` block of your `schema.prisma` file, add the following:

```prisma
binaryTargets = ["native", "linux-arm64-openssl-1.0.x"]
```

Update the Serverless configuration file to package the `arm64` binary:

```
package:
  patterns:
    - '!node_modules/.prisma/client/libquery_engine-*'
    - 'node_modules/.prisma/client/libquery_engine-linux-arm64-*'
    - '!node_modules/prisma/libquery_engine-*'
    - '!node_modules/@prisma/engines/**'
```

### Deployment with <inlinecode>serverless-webpack</inlinecode>

If you use `serverless-webpack`, then you can use the [serverless-webpack-prisma](https://github.com/danieluhm2004/serverless-webpack-prisma) plugin without any additional configuration. `serverless-webpack-prisma` does the following:

1. Copies your `schema.prisma` with the Webpack plugin.
2. Runs the `prisma generate` command. This means that there is no need to add the command to the webpack options separately.
3. Packages the correct Prisma engine used in the Lambda. This can save more than 40mb of capacity.

<details><summary>If you do not use webpack yet</summary>

Install dependencies.

```sh
npm install -D webpack serverless-webpack webpack-node-externals
```

If your project uses TypeScript, install `ts-loader`:

```sh
npm install -D ts-loader
```

Create a `webpack.config.js` file in the project root directory, and copy and paste the following configuration:

```javascript file=webpack.config.js
/* eslint-disable @typescript-eslint/no-var-requires */
const path = require('path')
const nodeExternals = require('webpack-node-externals')
const slsw = require('serverless-webpack')
const { isLocal } = slsw.lib.webpack

module.exports = {
  target: 'node',
  stats: 'normal',
  entry: slsw.lib.entries,
  externals: [nodeExternals()],
  mode: isLocal ? 'development' : 'production',
  optimization: { concatenateModules: false },
  resolve: { extensions: ['.js'] },
  output: {
    libraryTarget: 'commonjs',
    filename: '[name].js',
    path: path.resolve(__dirname, '.webpack'),
  },
}
```

In the case of TypeScript, insert the following configuration inside `exports`:

```javascript file=webpack.config.js
// ...initial config
module.exports = {
  // ...initial config
  resolve: { extensions: ['.js', '.ts'] },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        loader: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  // ...initial config
}
```

Refer to the [Serverless Webpack documentation](https://www.serverless.com/plugins/serverless-webpack) for additional configuration.

</details>

To install the dev dependency, use the following command:

```sh
npm install -D serverless-webpack-prisma serverless
```

In `serverless.yml`, add `serverless-webpack` to the plugins list, as follows:

```yaml file=serverless.yml
plugins:
  - serverless-webpack
  - serverless-webpack-prisma

custom:
  webpack:
    includeModules: true
```

`serverless-webpack-prisma` automatically runs `prisma generate` so that you do not need to use the webpack script option separately as shown below.

```yaml file=serverless.yml
custom:
  webpack:
    packagerOptions:
      scripts:
        - prisma generate
```

`serverless-webpack-prisma` removes the unnecessary dependencies and packages the correct Prisma engine for your Lambda. Therefore, delete it in the `package.patterns` configuration in your `serverless.yml` file.

```yaml file=serverless.yml
package:
  patterns:
    - '!node_modules/.prisma/client/libquery_engine-*'
    - 'node_modules/.prisma/client/libquery_engine-rhel-*'
    - '!node_modules/prisma/libquery_engine-*'
    - '!node_modules/@prisma/engines/**'
```

When you've updated your `serverless.yml` file, redeploy your application. To do so, run `serverless deploy`. The deployment output shows you that the correct Prisma Engine is packaged and distributed, as follows:

```code no-copy
Serverless: Copy prisma schema for app...
Serverless: Generate prisma client for app...
Serverless: Remove unused prisma engine:
Serverless: - node_modules/.prisma/client/libquery_engine-darwin.dylib.node
Serverless: - node_modules/@prisma/engines/introspection-engine-darwin
Serverless: - node_modules/@prisma/engines/libquery_engine-darwin.dylib.node
Serverless: - node_modules/@prisma/engines/migration-engine-darwin
Serverless: - node_modules/@prisma/engines/prisma-fmt-darwin
Serverless: Copying existing artifacts...
```

<Admonition type = "warning" >

** TBW: Consider doing the following ticket... **

we mention how to remove unneeded artifacts but only when using the serveless framework, I think we could improve that and mention how to do that when using AWS Lambda alone.

Example:

Create a zip script that only zips what's needed, for example
prisma/ecosystem-tests@dev/platforms-serverless/lambda/zip.sh
Then upload the zip

```terminal
aws lambda update-function-code --function-name my-function --zip-file "fileb://lambda.zip"
```

</Admonition>

## Summary

Congratulations! You have successfully deployed the API to AWS Lambda.

For more insight into Prisma Client's API, look at the function handlers in the `handlers/` folder.

<Admonition type="info">

**A note on connection pooling**

Generally, when you use a FaaS (function as a service) environment to interact with a database, every function invocation can result in a new connection to the database. This is not a problem with a constantly running node.js server. Therefore, it is beneficial to pool DB connections to get better performance. For some solutions to this issue, see the [connection management guide for serverless environments](/guides/performance-and-optimization/connection-management#serverless-environments-faas).

</Admonition>
