---
title: 'Deploy to AWS Lambda'
metaTitle: 'Deploy to AWS Lambda'
metaDescription: 'Learn how to deploy Node.js and TypeScript applications based on Prisma Client to AWS Lambda.'
---

<TopBlock>

This guide explains how to set up and deploy a serverless Node.js REST API to [AWS Lambda](https://aws.amazon.com/lambda/) with the Serverless Framework.

AWS Lambda is part of the AWS cloud platform. It allows you to use the serverless paradigm to run your code without managing servers. To deploy a REST API to AWS Lambda, you must also use [S3](https://aws.amazon.com/s3/) to host the files and [API Gateway](https://aws.amazon.com/api-gateway/) to expose the API over HTTP.

The Serverless Framework simplifies the deployment to Lambda with a CLI that helps with workflow automation and AWS resource provisioning.

The REST API uses Prisma Client to fetch, create, and delete records from a database. Each function represents a REST resource endpoint and uses Prisma Client to handle database operations against a PostgreSQL database hosted on a platform such as Heroku.

This guide shows how to deploy an API based on Prisma to AWS Lambda. The starting point is the [Prisma AWS example](https://github.com/prisma/prisma-examples/tree/latest/deployment-platforms/aws-lambda), which has a couple of REST endpoints preconfigured as serverless functions.

</TopBlock>

## If you deploy GraphQL servers to AWS Lambda

** TBD Change this to an admonition, and put this under a different heading **

While this example uses REST, the same principles apply to a GraphQL server. The main difference is that you typically only need a single function to serve a GraphQL API.

In that function, you must set the `context.callbackWaitsForEmptyEventLoop` of the [AWS Lambda Context Object](https://docs.aws.amazon.com/lambda/latest/dg/nodejs-context.html) to `false` as follows:

```js
exports.server = (event, context, cb) => {
  // Set to false to send the response right away when the callback executes, instead of waiting for the Node.js event loop to be empty.
  context.callbackWaitsForEmptyEventLoop = false

  return lambda.graphqlHandler(event, context, cb)
}
```

## Prerequisites

- a hosted PostgreSQL database and a URL from which your application can access it, such as `postgresql://username:password@your_postgres_db.cloud.com/db_identifier` (you can use Heroku, which offers a [free plan](https://dev.to/prisma/how-to-setup-a-free-postgresql-database-on-heroku-1dc1)).
- an [AWS](https://aws.amazon.com/) account and a corresponding [access key](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html) for programmatic access.
- a [Serverless Framework CLI](https://www.serverless.com/framework/docs/getting-started/) installed.
- PostgreSQL CLI `psql` installed.
- Node.js installed.

## Prisma workflow

The workflow depends on whether you integrate with an existing database or create a new one from scratch. Regardless of the workflow, Prisma relies on the Prisma schema, in other words the `schema.prisma` file.

This guide starts with an empty database created with plain SQL and looks as follows:

** TBW: I think this part is unclear - it isn't a set of prerequisite steps, and it doesn't mirror the structure of the page. **

1. Define the database schema with SQL.
1. Run `prisma db pull` locally, which introspects and populates the `schema.prisma` with models based on the database schema.
1. Run `prisma generate` which generates Prisma Client based on the Prisma schema.

## 1. Download the example

### Steps

Open your terminal window and navigate to a location of your choice. Create the directory that you want to hold the application code, then download the example code:

```terminal
mkdir prisma-aws-lambda
cd prisma-aws-lambda
curl https://codeload.github.com/prisma/prisma-examples/tar.gz/latest | tar -xz --strip=3 prisma-examples-latest/deployment-platforms/aws-lambda/
```

Now install the dependencies:

```
npm install
```

<!-- tar strip folder is a concatenation of the REPOSITORY-BRANCH/REF, e.g. prisma-examples-latest -->

### Result

Your directory contains the following files:

```terminal
ls -1
README.md
aws-credentials
handlers
node_modules
package-lock.json
package.json
prisma
schema.sql
serverless.yml
```

## 2. Set the DATABASE_URL environment variable locally

### Steps

Set the `DATABASE_URL` environment variable locally as follows. This lets you create the database schema and ensures that Prisma can access the database to introspect.

```terminal
export DATABASE_URL="postgresql://__USER__:__PASSWORD__@__HOST__/__DATABASE__"
```

> **Note:** you need the `DATABASE_URL` environment variable for the subsequent steps in this guide. Set it in all terminal sessions related to this project.

You need to replace the uppercase placeholders with your database credentials, e.g.:

```terminal
postgresql://janedoe:randompassword@yourpostgres.compute-1.amazonaws.com:5432/yourdbname
```

## 3. Set the DATABASE_URL in `.env`

The Lambda functions need access to the `DATABASE_URL` environment variable so that they can access the database. You must define an `.env` file which the preconfigured `serverless-dotenv-plugin` uses to inject into the function runtime. The repository contains an `.env.example` example file to assist with this.

Copy the following file:

**TBW - copy it from/to where? **

```
cp .env.example .env
```

Then open the .env file and set the `DATABASE_URL` with the database credentials from step 2.

> **Note:** When working with Git repositories, it's best practice to keep secrets, e.g. DATABASE_URL out of the repository. To do this, add your `.env` file to `.gitignore`. This guide only copies the source without creating a repository, so this is not necessary unless you initialize a repository.

** TBD: I am not sure what the second sentence above means - need to clarify it **

## 4. Create the database schema

To create your database schema, run `schema.sql` from the example code with the following command:

```terminal
psql $DATABASE_URL -f schema.sql
```

### Result

`psql $DATABASE_URL -c "\dt"` shows the following list of tables:

```terminal
          List of relations
 Schema | Name    | Type  | Owner
 --------+---------+-------+-----------
 public | Post    | table | janedoe
 public | Profile | table | janedoe
 public | User    | table | janedoe
```

Congratulations, you have successfully created the database schema!

## 5. Introspect the database

### Steps

Introspect the database with the following Prisma CLI command:

```terminal
npx prisma db pull
```

Prisma introspects the database that is defined in the `datasource` block of the Prisma schema. It populates the Prisma schema with models corresponding to the database tables.

### Result

`prisma/schema.prisma` looks as follows (note: in the following example we reordered the models for better readability):

```prisma file=schema.prisma
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  title     String
  content   String?
  published Boolean  @default(false)
  User      User     @relation(fields: [authorId], references: [id]) // relation field
  authorId  Int // relation scalar field
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique // relation scalar field
  User   User    @relation(fields: [userId], references: [id]) // relation field
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  Post    Post[] // relation field
  Profile Profile? // relation field
}
```

You can now run `prisma generate` to generate Prisma Client based on your new Prisma schema.

<Admonition type = "info">

When you make changes to your Prisma schema, invoke `prisma generate` to update your Prisma Client API.

</Admonition>

### Rename the relation fields for easy access

The generated `Post` and `Profile` fields in the `User` model are _virtual_. This means that they are _not backed by a foreign key in the database_). You can manually rename them in your Prisma schema, and this only affects the generated client. You typically do this to give your fields more meaningful names in the context of the relation.

In the resulting Prisma schema there are two types of relation fields:

- Relation fields: identified by having a model name as the type, such as the `User` field in the `Post` model. You can rename a relation field to better fit its usage, such as `User` -> `author`.
- [Relation scalar fields](/concepts/components/prisma-schema/relations): these store the foreign key, such as the `authorId` field in the `Post` model. You cannot rename a relation scalar field, because it must match the corresponding field in the database.

Prisma Client uses the names of the relation fields to access the corresponding relations. For example, the following example uses a relation field to fetch a specific `Post` and its associated `User` object in the above schema:

```js
const postAuthor = await prisma.post.findUnique({
  where: { id: 1 },
  include: { User: true },
})
```

If you rename the `User` field in the `Post` model to `author`, you can access it as follows:

```js
const postAuthor = await prisma.post.findUnique({
  where: { id: 1 },
  include: { author: true },
})
```

Based on that logic, rename the relation fields to follow the [naming conventions](/reference/api-reference/prisma-schema-reference#naming-conventions-1) <span class="api"></span>:

```prisma file=schema.prisma
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id]) // renamed from `User` -> `author`
  authorId  Int // relation scalar field
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique // relation scalar field
  user   User    @relation(fields: [userId], references: [id]) // renamed from `User` -> `user`
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[] // renamed from `Post` -> `posts`
  profile Profile? // renamed from `Profile` -> `profile`
}
```

## 6. Set the AWS Access key as an environment variable

In order for the Serverless Framework to provision the AWS resources and deploy your application, you must configure the access key.

There are different ways to get the access key, depending on whether you use your personal account or create a special IAM user for the Serverless Framework (this approach is recommended for security reasons because it allows you to set granular permissions). To get an access key for your account, follow the [AWS guide](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html#Using_CreateAccessKey)

** TBD: I am not sure if the above link applies to a personal account, an IAM user, or both - the above needs to be clarified **

When you have the _Access key ID_ and a _Secret access key_, set them with the following command:

```
serverless config credentials --provider aws --key AWS_ACCESS_KEY_ID  --secret AWS_SECRET_ACCESS_KEY
```

** TBD: change placeholders to be consistent - note the case disparity **

## 7. Deploy the app

### Steps

To deploy your project, use the following command:

```terminal
serverless deploy
```

Serverless will create the AWS resources and upload your code, and output the service information:

```
Service Information
service: prisma-aws-lambda-example
stage: dev
region: us-east-1
stack: prisma-aws-lambda-example-dev
resources: 39
api keys:
  None
endpoints:
  GET - https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/
  GET - https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/seed
  GET - https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/users
  POST - https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/users
  GET - https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/posts
functions:
  status: prisma-aws-lambda-example-dev-status
  seed: prisma-aws-lambda-example-dev-seed
  getUsers: prisma-aws-lambda-example-dev-getUsers
  createUser: prisma-aws-lambda-example-dev-createUser
  getPosts: prisma-aws-lambda-example-dev-getPosts
layers:
  None
```

### Result

Call the status endpoint as follows:

```terminal
curl https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/
```

This returns `{"up":true}`

## 8. Test your deployed REST API

With the API base URL: `https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/`, you can test the API's endpoints:

| Endpoint      | Description                                                                                                              | Implementation            |
| ------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------------- |
| `GET /`       | Status                                                                                                                   | `handlers/status.js`      |
| `GET /seed`   | Delete all database records and seed the database with test `users`, `profiles`, and `posts`. Returns the created users. | `handlers/seed.js`        |
| `GET /users`  | Fetch all `users` in the database with their related `profiles`                                                          | `handlers/users.js`       |
| `POST /users` | Create a single `users` in the database                                                                                  | `handlers/create-user.js` |
| `GET /posts`  | Fetch all `posts` and their related `authors`                                                                            | `handlers/posts.js`       |

To call the API, you can use curl:

```
curl -v https://UNIQUE_IDENTIFIER.execute-api.us-east-1.amazonaws.com/dev/seed
```

## Notes

### `serverless.yml`

The `serverless.yml` configuration file is where the endpoint and function configuration lives. You can update this file to add or change endpoints. For more AWS specific configuration, check out the AWS provider configuration in the [Serverless Framework Docs](https://serverless.com/framework/docs/providers/aws/guide/functions/).

### Binary targets in `schema.prisma`

The Prisma schema contains the following in the generator block:

```
binaryTargets = ["native", "rhel-openssl-1.0.x"]
```

This is necessary as the local runtime is different to the Lambda runtime. Adding the `binaryTarget` will ensure that the compatible Prisma Engine binary is available.

### Package Pattern in `serverless.yml`

The Serverless configuration file includes a package pattern that excludes all Prisma Engine binaries but the one relevant for the Lambda runtime, so only 1 binary will be included when Serverless packages your app for upload:

```
package:
  patterns:
    - '!node_modules/.prisma/client/libquery_engine-*'
    - 'node_modules/.prisma/client/libquery_engine-rhel-*'
    - '!node_modules/prisma/libquery_engine-*'
    - '!node_modules/@prisma/engines/**'
```

This ensures the packaged archive is as small as possible.

But, if you are using `serverless-webpack`, you cannot use that method.

### Lambdas with arm64 architectures

Lambda functions that use [arm64 architectures (AWS Graviton2 processor)](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html#foundation-arch-adv) must use an `arm64` precompiled binary.

In the `generator` block of your `schema.prisma` file, add the following:

```
binaryTargets = ["native", "linux-arm64-openssl-1.0.x"]
```

Update the Serverless configuration file to package the `arm64` binary:

```
package:
  patterns:
    - '!node_modules/.prisma/client/libquery_engine-*'
    - 'node_modules/.prisma/client/libquery_engine-linux-arm64-*'
    - '!node_modules/prisma/libquery_engine-*'
    - '!node_modules/@prisma/engines/**'
```

### Deployment using `serverless-webpack`

If you are using `serverless-webpack`, you can use the [serverless-webpack-prisma](https://github.com/danieluhm2004/serverless-webpack-prisma) plugin without any additional configuration. `serverless-webpack-prisma` does the following:

1. Copies your `schema.prisma` via the Webpack plugin
2. Runs the `prisma generate` command. This means there is no need to add the command to the webpack options separately
3. Packages the correct Prisma engine used in the Lambda. This can save more than 40mb of capacity.

<details><summary>If you are not using webpack yet</summary>

Install dependencies.

```sh
npm install -D webpack serverless-webpack webpack-node-externals
```

Install`ts-loader` if your project uses TypeScript.

```sh
npm install -D ts-loader
```

Next, create a `webpack.config.js` file in the project root directory and copy and paste the following configuration.

```javascript file=webpack.config.js
/* eslint-disable @typescript-eslint/no-var-requires */
const path = require('path')
const nodeExternals = require('webpack-node-externals')
const slsw = require('serverless-webpack')
const { isLocal } = slsw.lib.webpack

module.exports = {
  target: 'node',
  stats: 'normal',
  entry: slsw.lib.entries,
  externals: [nodeExternals()],
  mode: isLocal ? 'development' : 'production',
  optimization: { concatenateModules: false },
  resolve: { extensions: ['.js'] },
  output: {
    libraryTarget: 'commonjs',
    filename: '[name].js',
    path: path.resolve(__dirname, '.webpack'),
  },
}
```

In the case of TypeScript, we also insert the following configuration inside `exports`:

```javascript file=webpack.config.js
// ...initial config
module.exports = {
  // ...initial config
  resolve: { extensions: ['.js', '.ts'] },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        loader: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  // ...initial config
}
```

Refer to the [Serverless Webpack documentation](https://www.serverless.com/plugins/serverless-webpack) for additional configuration.

</details>

Install the dev dependency by entering the following command:

```sh
npm install -D serverless-webpack-prisma serverless
```

Update your `serverless.yml` by adding the `serverless-webpack` to the plugins list.

```yaml file=serverless.yml
plugins:
  - serverless-webpack
  - serverless-webpack-prisma

custom:
  webpack:
    includeModules: true
```

`serverless-webpack-prisma` automatically runs `prisma generate` so you don't need to use the webpack script option separately as shown below.

```yaml file=serverless.yml
custom:
  webpack:
    packagerOptions:
      scripts:
        - prisma generate
```

`serverless-webpack-prisma` removes the unnecessary dependencies and packages the right Prisma engine to be used in your Lambda. Therefore, delete it in the `package.patterns` configuration in your `serverless.yml` file.

```yaml file=serverless.yml
package:
  patterns:
    - '!node_modules/.prisma/client/libquery_engine-*'
    - 'node_modules/.prisma/client/libquery_engine-rhel-*'
    - '!node_modules/prisma/libquery_engine-*'
    - '!node_modules/@prisma/engines/**'
```

Once you've updated your `serverless.yml` file, redeploy your application by running `serverless deploy`. The deployment output will show you the correct Prisma Engine is packaged and distributed.

```
Serverless: Copy prisma schema for app...
Serverless: Generate prisma client for app...
Serverless: Remove unused prisma engine:
Serverless: - node_modules/.prisma/client/libquery_engine-darwin.dylib.node
Serverless: - node_modules/@prisma/engines/introspection-engine-darwin
Serverless: - node_modules/@prisma/engines/libquery_engine-darwin.dylib.node
Serverless: - node_modules/@prisma/engines/migration-engine-darwin
Serverless: - node_modules/@prisma/engines/prisma-fmt-darwin
Serverless: Copying existing artifacts...
```

<Admonition type = "warning" >

** TBW: Consider doing the following ticket... **

we mention how to remove unneeded artifacts but only when using the serveless framework, I think we could improve that and mention how to do that when using AWS Lambda alone.

Example:

Create a zip script that only zips what's needed, for example
prisma/ecosystem-tests@dev/platforms-serverless/lambda/zip.sh
Then upload the zip

```terminal
aws lambda update-function-code --function-name my-function --zip-file "fileb://lambda.zip"
```

</Admonition>

## Summary

Congratulations! You have successfully deployed the API to AWS Lambda.

For more insight into Prisma Client's API, look at the function handlers in the `handlers/` folder.

Generally, when using a FaaS (function as a service) environment to interact with a database, it's beneficial to pool DB connections for performance reasons. This is because every function invocation may result in a new connection to the database (this is not a problem with a constantly running node.js server). For more information on some of the solutions, refer to the [connection management guide for serverless environments](/guides/performance-and-optimization/connection-management#serverless-environments-faas).
